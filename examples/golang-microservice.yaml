# Example: Go Microservice
# Use case: Go backend service with comprehensive testing and deployment

name: CI

on:
  push:
    branches: [main, develop, 'release/**', 'hotfix/**']
  pull_request:
    branches: [main, develop]

# Prevent duplicate runs: cancel in-progress runs when new commits are pushed
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  APP_NAME: auth-service
  PROJECT: platform
  GITOPS_REPO: mrops-br/gitops-platform

jobs:
  build-and-deploy:
    name: Build & Deploy
    uses: mrops-br/gha-workflows/.github/workflows/_pipeline-golang.yaml@main
    permissions:
      contents: read
      packages: write
      id-token: write
      security-events: write
    secrets: inherit
    with:
      app-name: ${{ env.APP_NAME }}
      project: ${{ env.PROJECT }}
      gitops-repo: ${{ env.GITOPS_REPO }}
      go-version: '1.23'
      working-directory: '.'
      dockerfile: build/Dockerfile
      enable-lint: true
      enable-test: true
      enable-coverage: true

# Project structure expected:
# ├── go.mod
# ├── go.sum
# ├── .golangci.yml (optional, uses defaults if missing)
# ├── cmd/
# │   └── server/
# │       └── main.go
# ├── internal/
# │   ├── handler/
# │   ├── service/
# │   └── repository/
# ├── pkg/
# ├── build/
# │   └── Dockerfile
# └── .github/
#     └── workflows/
#         └── pipeline.yaml (this file)

# CI Pipeline runs:
# 1. golangci-lint (linting)
# 2. go test ./... (unit tests)
# 3. go test -race (race detection)
# 4. go test -coverprofile (coverage report)
# 5. gosec (security scanning)

# Then builds Docker image and deploys via GitOps
